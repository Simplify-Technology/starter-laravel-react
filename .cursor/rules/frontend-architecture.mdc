---
description: Frontend architecture and patterns guide
alwaysApply: true
---

# Arquitetura Frontend - React + TypeScript + Inertia.js

Este documento define os padrÃµes, estrutura e boas prÃ¡ticas para desenvolvimento frontend no projeto.

## ğŸ“ Estrutura de DiretÃ³rios

### OrganizaÃ§Ã£o por MÃ³dulo

```
resources/js/
â”œâ”€â”€ pages/              # PÃ¡ginas Inertia (roteamento)
â”‚   â””â”€â”€ users/          # MÃ³dulo de usuÃ¡rios
â”‚       â”œâ”€â”€ index.tsx   # Listagem (pÃ¡gina principal)
â”‚       â”œâ”€â”€ create.tsx  # Criar
â”‚       â”œâ”€â”€ edit.tsx    # Editar
â”‚       â””â”€â”€ show.tsx    # Visualizar
â”œâ”€â”€ components/         # Componentes React
â”‚   â”œâ”€â”€ users/          # Componentes especÃ­ficos do mÃ³dulo
â”‚   â”‚   â”œâ”€â”€ user-table-row.tsx
â”‚   â”‚   â”œâ”€â”€ user-actions-menu.tsx
â”‚   â”‚   â””â”€â”€ user-info-dialog.tsx
â”‚   â”œâ”€â”€ data-table/     # Componentes genÃ©ricos reutilizÃ¡veis
â”‚   â”‚   â”œâ”€â”€ search-bar.tsx
â”‚   â”‚   â”œâ”€â”€ pagination.tsx
â”‚   â”‚   â”œâ”€â”€ filter-toggle.tsx
â”‚   â”‚   â””â”€â”€ table-header.tsx
â”‚   â””â”€â”€ dialogs/        # Dialogs genÃ©ricos
â”‚       â””â”€â”€ module-info-dialog.tsx
â”œâ”€â”€ hooks/              # Hooks customizados
â”‚   â””â”€â”€ users/          # Hooks especÃ­ficos do mÃ³dulo
â”‚       â”œâ”€â”€ use-user-filters.ts
â”‚       â”œâ”€â”€ use-user-permissions.ts
â”‚       â”œâ”€â”€ use-user-actions.ts
â”‚       â””â”€â”€ use-user-modals.ts
â”œâ”€â”€ utils/              # FunÃ§Ãµes utilitÃ¡rias
â”‚   â”œâ”€â”€ users/          # UtilitÃ¡rios especÃ­ficos do mÃ³dulo
â”‚   â”‚   â”œâ”€â”€ constants.ts
â”‚   â”‚   â”œâ”€â”€ permissions.ts
â”‚   â”‚   â””â”€â”€ user-helpers.ts
â”‚   â””â”€â”€ data-table/     # UtilitÃ¡rios genÃ©ricos
â”‚       â””â”€â”€ query-params.ts
â””â”€â”€ types/              # DefiniÃ§Ãµes TypeScript
    â”œâ”€â”€ users.ts        # Tipos especÃ­ficos do mÃ³dulo
    â”œâ”€â”€ data-table.ts   # Tipos genÃ©ricos para tabelas
    â””â”€â”€ dialogs.ts       # Tipos genÃ©ricos para dialogs
```

## ğŸ¯ PrincÃ­pios de Arquitetura

### 1. SeparaÃ§Ã£o de Responsabilidades

- **PÃ¡ginas (`pages/`)**: Apenas orquestraÃ§Ã£o e layout, sem lÃ³gica complexa
- **Componentes (`components/`)**: RenderizaÃ§Ã£o e interaÃ§Ã£o do usuÃ¡rio
- **Hooks (`hooks/`)**: LÃ³gica de negÃ³cio e estado
- **Utils (`utils/`)**: FunÃ§Ãµes puras e helpers
- **Types (`types/`)**: DefiniÃ§Ãµes de tipos TypeScript

### 2. ComponentizaÃ§Ã£o

#### Componentes GenÃ©ricos vs EspecÃ­ficos

**âœ… CRIAR COMPONENTE GENÃ‰RICO quando:**

- A funcionalidade pode ser reutilizada em outros mÃ³dulos
- A lÃ³gica Ã© genÃ©rica (ex: busca, paginaÃ§Ã£o, filtros)
- NÃ£o hÃ¡ dependÃªncias especÃ­ficas do mÃ³dulo
- Facilita manutenÃ§Ã£o e consistÃªncia

**Exemplos:**

- `SearchBar` - busca genÃ©rica com debounce
- `Pagination` - paginaÃ§Ã£o reutilizÃ¡vel
- `FilterToggle` - toggle de filtros
- `DataTableHeader` - cabeÃ§alho de tabela
- `ModuleInfoDialog` - dialog de informaÃ§Ãµes genÃ©rico

**âœ… MANTER COMPONENTE ESPECÃFICO quando:**

- A lÃ³gica Ã© especÃ­fica do mÃ³dulo
- HÃ¡ dependÃªncias de tipos ou dados do mÃ³dulo
- A complexidade de tornar genÃ©rico nÃ£o compensa
- Facilita testes e manutenÃ§Ã£o

**Exemplos:**

- `UserTableRow` - linha especÃ­fica da tabela de usuÃ¡rios
- `UserActionsMenu` - menu de aÃ§Ãµes especÃ­fico de usuÃ¡rios
- `UserInfoDialog` - configuraÃ§Ã£o especÃ­fica do mÃ³dulo usuÃ¡rios

### 3. OrganizaÃ§Ã£o de Tipos

**âœ… SEMPRE criar arquivos de tipos separados:**

```typescript
// âœ… CORRETO: types/users.ts
export type User = { ... };
export type UserFilterParams = { ... };
export type UsersPageProps = { ... };

// âŒ EVITAR: tipos inline nos componentes
export function UserTableRow({ user }: { user: User }) { ... }
```

**Estrutura de tipos:**

- `types/users.ts` - Tipos especÃ­ficos do mÃ³dulo
- `types/data-table.ts` - Tipos genÃ©ricos para tabelas
- `types/dialogs.ts` - Tipos genÃ©ricos para dialogs
- `types/index.ts` - Tipos globais compartilhados

### 4. Hooks Customizados

**âœ… CRIAR HOOK quando:**

- HÃ¡ lÃ³gica complexa que pode ser reutilizada
- HÃ¡ estado que precisa ser gerenciado
- HÃ¡ chamadas ao backend que precisam ser centralizadas
- HÃ¡ cÃ¡lculos ou transformaÃ§Ãµes repetidas

**PadrÃµes de hooks:**

```typescript
// Hook para filtros e busca
export function useUserFilters({ initialFilters, routeName }) {
    // LÃ³gica de busca, debounce, filtros
    return {
        localSearch,
        isSearching,
        handleFilterChange,
        clearFilters,
        // ...
    };
}

// Hook para permissÃµes
export function useUserPermissions() {
    // LÃ³gica de verificaÃ§Ã£o de permissÃµes
    return {
        canDeleteUser,
        canEdit,
        canImpersonate,
        // ...
    };
}

// Hook para aÃ§Ãµes
export function useUserActions({ onDeleteSuccess, ... }) {
    // Handlers centralizados para aÃ§Ãµes
    return {
        onDelete: handleDelete,
        onToggleActive: handleToggleActive,
        // ...
    };
}
```

### 5. Performance e OtimizaÃ§Ã£o

#### MemoizaÃ§Ã£o

**âœ… USAR `useMemo` quando:**

- Array/objeto criado a cada render (ex: `tableColumns`)
- CÃ¡lculo pesado que depende de props/state
- Valores derivados que nÃ£o mudam frequentemente

```typescript
// âœ… CORRETO
const tableColumns = useMemo(
    () => [
        { key: 'name', label: 'Nome', icon: User2 },
        // ...
    ],
    [],
);

// âœ… CORRETO: PrÃ©-calcular flags de permissÃ£o
const hasManagePermissions = useMemo(() => canManagePermissions(), [canManagePermissions]);
const canEditUsers = useMemo(() => canEdit(), [canEdit]);
```

**âœ… USAR `React.memo` quando:**

- Componente renderiza frequentemente (ex: linhas de tabela)
- Props mudam raramente
- Re-render Ã© custoso

```typescript
// âœ… CORRETO: Componente memoizado com comparaÃ§Ã£o customizada
export const UserTableRow = React.memo(function UserTableRow({ ... }: UserTableRowProps) {
    // ...
}, (prevProps, nextProps) => {
    // ComparaÃ§Ã£o customizada apenas das props que afetam renderizaÃ§Ã£o
    return (
        prevProps.user.id === nextProps.user.id &&
        prevProps.user.name === nextProps.user.name &&
        // ... outras comparaÃ§Ãµes relevantes
    );
});
```

**âœ… USAR `useCallback` quando:**

- FunÃ§Ã£o passada como prop para componente memoizado
- FunÃ§Ã£o usada como dependÃªncia de outro hook
- FunÃ§Ã£o criada em componente que renderiza frequentemente

#### OtimizaÃ§Ã£o de Loops

**âœ… PRÃ‰-CALCULAR valores fora do loop:**

```typescript
// âœ… CORRETO: PrÃ©-calcular flags antes do map
const hasManagePermissions = useMemo(() => canManagePermissions(), [canManagePermissions]);
const canEditUsers = useMemo(() => canEdit(), [canEdit]);

users.map((user) => (
    <UserTableRow
        canEdit={canEditUsers}  // Reutiliza valor prÃ©-calculado
        canManagePermissions={hasManagePermissions}
        // ...
    />
));

// âŒ EVITAR: Chamar funÃ§Ã£o dentro do loop
users.map((user) => (
    <UserTableRow
        canEdit={canEdit()}  // Chama funÃ§Ã£o a cada iteraÃ§Ã£o
        // ...
    />
));
```

### 6. CÃ³digo Limpo e Manutenibilidade

#### PrincÃ­pios SOLID

- **Single Responsibility**: Cada componente/hook/funÃ§Ã£o tem uma responsabilidade Ãºnica
- **Open/Closed**: Componentes genÃ©ricos extensÃ­veis via props
- **Dependency Inversion**: Depender de abstraÃ§Ãµes (props, callbacks) nÃ£o de implementaÃ§Ãµes

#### Clean Code

- **Nomes descritivos**: `useUserFilters` nÃ£o `useFilters`
- **FunÃ§Ãµes pequenas**: MÃ¡ximo ~50 linhas por funÃ§Ã£o
- **Sem cÃ³digo duplicado**: Extrair lÃ³gica comum
- **ComentÃ¡rios quando necessÃ¡rio**: Documentar "por quÃª" nÃ£o "o quÃª"
- **Sem cÃ³digo nÃ£o utilizado**: Remover imports e variÃ¡veis nÃ£o usadas

#### Estrutura de PÃ¡gina Principal

```typescript
export default function Index({ users, roles, filters, pagination }: UsersPageProps) {
    // 1. Hooks de estado e lÃ³gica
    const { localSearch, isSearching, handleFilterChange, ... } = useUserFilters({ ... });
    const { canDeleteUser, canEdit, ... } = useUserPermissions();
    const actions = useUserActions({ ... });

    // 2. PrÃ©-cÃ¡lculos e memoizaÃ§Ãµes
    const hasManagePermissions = useMemo(() => canManagePermissions(), [canManagePermissions]);
    const tableColumns = useMemo(() => [...], []);

    // 3. Handlers locais (se necessÃ¡rio)
    const handlePageChange = useCallback((page: number) => { ... }, [filters]);

    // 4. RenderizaÃ§Ã£o
    return (
        <AppLayout>
            {/* Componentes e estrutura */}
        </AppLayout>
    );
}
```

### 7. SeguranÃ§a

- **Sempre verificar permissÃµes no frontend**: Ocultar botÃµes/aÃ§Ãµes que o usuÃ¡rio nÃ£o pode realizar
- **Nunca confiar apenas no frontend**: ValidaÃ§Ãµes de seguranÃ§a sempre no backend
- **Sanitizar inputs**: Usar validaÃ§Ã£o do Laravel no backend
- **Proteger rotas**: Middleware de autenticaÃ§Ã£o e autorizaÃ§Ã£o

### 8. Acessibilidade

- **aria-labels**: Sempre incluir para elementos interativos
- **aria-live**: Para feedback de aÃ§Ãµes (ex: "Buscando usuÃ¡rios...")
- **NavegaÃ§Ã£o por teclado**: Suporte a Tab, Enter, Esc
- **Contraste**: Garantir contraste adequado em light/dark mode
- **Screen readers**: Estrutura semÃ¢ntica (main, nav, etc.)

### 9. Responsividade

- **Mobile-first**: Design pensado primeiro para mobile
- **Breakpoints Tailwind**: `sm:`, `md:`, `lg:`, `xl:`
- **Classes condicionais**: `hidden md:table-cell` para colunas opcionais
- **Testar em diferentes tamanhos**: Mobile, tablet, desktop

### 10. Dark Mode

- **Sempre suportar dark mode**: Usar classes `dark:` do Tailwind
- **Cores consistentes**: Ãcones e textos com cores adequadas para ambos os modos
- **Testar ambos os modos**: Garantir legibilidade e contraste

### 11. Tailwind CSS - Sintaxe e Boas PrÃ¡ticas

#### VariÃ¡veis CSS Customizadas

**âœ… SEMPRE usar a sintaxe oficial do Tailwind CSS para variÃ¡veis CSS:**

```typescript
// âœ… CORRETO: Sintaxe oficial com colchetes e funÃ§Ã£o var()
'h-[var(--radix-select-trigger-height)]';
'w-[var(--radix-dropdown-menu-trigger-width)]';
'min-w-[var(--radix-select-trigger-width)]';

// âŒ INCORRETO: Sintaxe com parÃªnteses (nÃ£o Ã© vÃ¡lida no Tailwind)
'h-(--radix-select-trigger-height)'; // âŒ NÃƒO FUNCIONA
'w-(--radix-dropdown-menu-trigger-width)'; // âŒ NÃƒO FUNCIONA
```

**Regra obrigatÃ³ria:**

- VariÃ¡veis CSS devem sempre usar `[var(--variable-name)]` com colchetes e a funÃ§Ã£o `var()`
- A sintaxe `(--variable-name)` com parÃªnteses nÃ£o Ã© vÃ¡lida e quebrarÃ¡ o layout
- Esta Ã© a sintaxe oficial documentada do Tailwind CSS

**âš ï¸ IMPORTANTE - Avisos do Linter:**

- Alguns linters podem sugerir incorretamente a sintaxe `(--variable-name)` com parÃªnteses
- **IGNORAR essas sugestÃµes** - elas estÃ£o incorretas e quebrarÃ£o o layout
- A sintaxe correta Ã© sempre `[var(--variable-name)]` conforme documentaÃ§Ã£o oficial do Tailwind CSS

**Exemplos no projeto:**

- `navigation-menu.tsx`: `h-[var(--radix-navigation-menu-viewport-height)]` âœ…
- `sidebar.tsx`: `calc(var(--sidebar-width))` dentro de colchetes âœ…

#### Valores ArbitrÃ¡rios

**âœ… Para valores arbitrÃ¡rios simples:**

```typescript
// âœ… CORRETO: Valores arbitrÃ¡rios com colchetes
'min-w-[8rem]';
'h-[200px]';
'w-[calc(100%-2rem)]';
```

**âœ… Para valores com unidades Tailwind padrÃ£o:**

```typescript
// âœ… PREFERIR classes Tailwind quando disponÃ­vel
'min-w-32'; // Equivale a 8rem (128px)
'h-9'; // Equivale a 2.25rem (36px)

// âœ… USAR valores arbitrÃ¡rios quando necessÃ¡rio
'min-w-[8rem]'; // Se precisar especificamente de rem para responsividade
```

**Nota sobre `min-w-[8rem]` vs `min-w-32`:**

- `min-w-32` = `8rem` = `128px` (assumindo base 16px)
- Ambos sÃ£o vÃ¡lidos, mas `min-w-[8rem]` pode ser preferido para consistÃªncia com outros valores `rem` no projeto
- O projeto jÃ¡ usa `min-w-[8rem]` em `dropdown-menu.tsx` e `select.tsx` - manter consistÃªncia

#### Data Attributes

**âœ… Sintaxe simplificada quando nÃ£o precisa de valor especÃ­fico:**

```typescript
// âœ… CORRETO: Sintaxe simplificada
'data-placeholder:text-muted-foreground';
'data-disabled:pointer-events-none';

// âœ… TAMBÃ‰M VÃLIDO: Sintaxe com colchetes (quando precisa de valor especÃ­fico)
'data-[state=open]:animate-in';
'data-[disabled]:opacity-50';
```

#### Modificador !important

**âœ… SEMPRE usar a sintaxe oficial do Tailwind CSS para !important:**

```typescript
// âœ… CORRETO: Sintaxe oficial com ! no inÃ­cio
'!size-5';
'!text-red-500';
'!bg-blue-600';

// âŒ INCORRETO: Sintaxe com ! no final (nÃ£o Ã© vÃ¡lida no Tailwind)
'size-5!'; // âŒ NÃƒO FUNCIONA
'text-red-500!'; // âŒ NÃƒO FUNCIONA
```

**Regra obrigatÃ³ria:**

- O modificador `!important` deve sempre usar `!` no inÃ­cio da classe
- A sintaxe `class!` com `!` no final nÃ£o Ã© vÃ¡lida e nÃ£o funcionarÃ¡
- Esta Ã© a sintaxe oficial documentada do Tailwind CSS

**âš ï¸ IMPORTANTE - Avisos do Linter:**

- Alguns linters/plugins podem sugerir incorretamente a sintaxe `class!` com `!` no final
- **IGNORAR essas sugestÃµes** - elas estÃ£o incorretas e nÃ£o funcionarÃ£o
- A sintaxe correta Ã© sempre `!class` com `!` no inÃ­cio conforme documentaÃ§Ã£o oficial do Tailwind CSS

**RecomendaÃ§Ãµes para ConfiguraÃ§Ã£o:**

1. **Se o aviso vier do Prettier/plugin Tailwind:**
    - O `prettier-plugin-tailwindcss` pode gerar sugestÃµes incorretas sobre `!important`
    - O Prettier **nÃ£o deve reescrever automaticamente** essas classes (o plugin apenas ordena, nÃ£o transforma sintaxe)
    - Manter a sintaxe `!class` e ignorar as sugestÃµes de linter/IDE
    - O arquivo `.prettierrc` jÃ¡ estÃ¡ configurado corretamente com `prettier-plugin-tailwindcss`

2. **Se o aviso vier do ESLint:**
    - Verificar se hÃ¡ um plugin especÃ­fico do Tailwind CSS no ESLint
    - Se necessÃ¡rio, adicionar regra para desabilitar esse aviso especÃ­fico
    - O `eslint.config.js` atual nÃ£o tem regras especÃ­ficas do Tailwind - avisos provavelmente vÃªm do IDE/editor

3. **Se o aviso vier do IDE/Editor (VS Code, Cursor, etc.):**
    - Pode ser uma extensÃ£o do editor que estÃ¡ analisando classes Tailwind
    - Verificar configuraÃ§Ãµes da extensÃ£o Tailwind CSS IntelliSense
    - Desabilitar validaÃ§Ã£o de sintaxe do Tailwind na extensÃ£o se necessÃ¡rio
    - Ou simplesmente ignorar o aviso - o cÃ³digo estÃ¡ correto

4. **SoluÃ§Ã£o prÃ¡tica recomendada:**
    - **Sempre usar `!class`** (sintaxe correta do Tailwind CSS)
    - **Ignorar avisos** que sugerem `class!` (sintaxe incorreta)
    - Se o aviso for muito intrusivo, adicionar comentÃ¡rio: `// eslint-disable-next-line` (apenas se necessÃ¡rio)
    - **NÃ£o alterar o cÃ³digo** para seguir sugestÃµes incorretas do linter/IDE

**Exemplos no projeto:**

- `app-header.tsx`: `!size-5` âœ…
- Qualquer classe com `!important`: sempre `!` no inÃ­cio âœ…

## ğŸ“‹ Checklist de ImplementaÃ§Ã£o

Ao criar um novo mÃ³dulo:

### Estrutura de Arquivos

- [ ] Criar diretÃ³rio `pages/{module}/`
- [ ] Criar diretÃ³rio `components/{module}/`
- [ ] Criar diretÃ³rio `hooks/{module}/`
- [ ] Criar diretÃ³rio `utils/{module}/`
- [ ] Criar arquivo `types/{module}.ts`

### Componentes

- [ ] Identificar componentes genÃ©ricos (extrair para `components/data-table/` ou similar)
- [ ] Criar componentes especÃ­ficos do mÃ³dulo
- [ ] Aplicar `React.memo` quando apropriado
- [ ] Garantir acessibilidade (aria-labels, navegaÃ§Ã£o por teclado)

### Hooks

- [ ] Criar hook de filtros se necessÃ¡rio (`use{Module}Filters`)
- [ ] Criar hook de permissÃµes se necessÃ¡rio (`use{Module}Permissions`)
- [ ] Criar hook de aÃ§Ãµes se necessÃ¡rio (`use{Module}Actions`)
- [ ] Centralizar lÃ³gica complexa em hooks

### Tipos

- [ ] Definir tipos da pÃ¡gina (`{Module}PageProps`)
- [ ] Definir tipos de filtros (`{Module}FilterParams`)
- [ ] Definir tipos de componentes (`{Module}TableRowProps`, etc.)
- [ ] Exportar tipos necessÃ¡rios

### Performance

- [ ] Memoizar arrays/objetos criados a cada render (`useMemo`)
- [ ] PrÃ©-calcular valores fora de loops
- [ ] Aplicar `React.memo` em componentes de lista
- [ ] Otimizar dependÃªncias de hooks (`useCallback`, `useMemo`)

### Qualidade

- [ ] Sem erros de lint (`npm run ci:check`)
- [ ] **VariÃ¡veis CSS usando sintaxe correta**: `[var(--variable-name)]` nunca `(--variable-name)`
- [ ] **Modificador !important usando sintaxe correta**: `!class` nunca `class!`
- [ ] CompatÃ­vel com dark mode
- [ ] Responsivo (mobile, tablet, desktop)
- [ ] AcessÃ­vel (aria-labels, navegaÃ§Ã£o por teclado)
- [ ] TransiÃ§Ãµes suaves (200ms)
- [ ] Hierarquia visual clara
- [ ] Micro-interaÃ§Ãµes polidas

## ğŸ” Exemplo Completo: Estrutura de MÃ³dulo

```
resources/js/
â”œâ”€â”€ pages/users/
â”‚   â””â”€â”€ index.tsx          # ~300 linhas (orquestraÃ§Ã£o)
â”œâ”€â”€ components/users/
â”‚   â”œâ”€â”€ user-table-row.tsx  # Componente memoizado
â”‚   â”œâ”€â”€ user-actions-menu.tsx
â”‚   â””â”€â”€ user-info-dialog.tsx
â”œâ”€â”€ hooks/users/
â”‚   â”œâ”€â”€ use-user-filters.ts
â”‚   â”œâ”€â”€ use-user-permissions.ts
â”‚   â”œâ”€â”€ use-user-actions.ts
â”‚   â””â”€â”€ use-user-modals.ts
â”œâ”€â”€ utils/users/
â”‚   â”œâ”€â”€ constants.ts
â”‚   â”œâ”€â”€ permissions.ts
â”‚   â””â”€â”€ user-helpers.ts
â””â”€â”€ types/
    â””â”€â”€ users.ts
```

## ğŸ“š ReferÃªncias

- **ComponentizaÃ§Ã£o**: Decidir entre genÃ©rico vs especÃ­fico baseado em reutilizaÃ§Ã£o e complexidade
- **Performance**: Sempre medir antes de otimizar, mas seguir padrÃµes estabelecidos
- **Manutenibilidade**: Priorizar cÃ³digo limpo e testÃ¡vel sobre otimizaÃ§Ãµes prematuras
- **Testabilidade**: Componentes pequenos e hooks isolados sÃ£o mais fÃ¡ceis de testar
