---
description: Backend architecture and patterns guide for Laravel
alwaysApply: true
---

# Arquitetura Backend - Laravel + PHP

> **âš ï¸ Importante**: Este guia fornece **padrÃµes recomendados** e **boas prÃ¡ticas**, nÃ£o regras rÃ­gidas. Use como referÃªncia e adapte conforme a necessidade especÃ­fica de cada mÃ³dulo. Quando uma abordagem diferente fizer mais sentido, priorize a soluÃ§Ã£o mais adequada ao contexto.

Este documento define os padrÃµes, estrutura e boas prÃ¡ticas para desenvolvimento backend no projeto, focando em performance, seguranÃ§a, manutenibilidade e testabilidade.

## ğŸ“ Estrutura de DiretÃ³rios

### OrganizaÃ§Ã£o por MÃ³dulo

```
app/
â”œâ”€â”€ Http/
â”‚   â”œâ”€â”€ Controllers/
â”‚   â”‚   â””â”€â”€ {Module}/           # MÃ³dulo especÃ­fico (ex: User, Client)
â”‚   â”‚       â”œâ”€â”€ IndexController.php
â”‚   â”‚       â”œâ”€â”€ CreateController.php
â”‚   â”‚       â”œâ”€â”€ StoreController.php
â”‚   â”‚       â”œâ”€â”€ ShowController.php
â”‚   â”‚       â”œâ”€â”€ EditController.php
â”‚   â”‚       â”œâ”€â”€ UpdateController.php
â”‚   â”‚       â””â”€â”€ DestroyController.php
â”‚   â”œâ”€â”€ Requests/
â”‚   â”‚   â””â”€â”€ {Module}/           # Form Requests por mÃ³dulo
â”‚   â”‚       â”œâ”€â”€ Store{Module}Request.php
â”‚   â”‚       â””â”€â”€ Update{Module}Request.php
â”‚   â””â”€â”€ Resources/
â”‚       â””â”€â”€ {Module}Resource.php # API Resources para transformaÃ§Ã£o
â”œâ”€â”€ Services/                    # ServiÃ§os de lÃ³gica de negÃ³cio
â”‚   â”œâ”€â”€ RoleFilterService.php
â”‚   â”œâ”€â”€ ImpersonationService.php
â”‚   â””â”€â”€ PermissionManagementService.php
â”œâ”€â”€ Policies/                    # Policies de autorizaÃ§Ã£o
â”‚   â””â”€â”€ {Module}Policy.php
â”œâ”€â”€ Models/                      # Eloquent Models
â”‚   â”œâ”€â”€ User.php
â”‚   â””â”€â”€ Role.php
â””â”€â”€ Traits/
    â””â”€â”€ Models/                  # Traits para Models
        â””â”€â”€ HasRolesAndPermissions.php
```

## ğŸ¯ PrincÃ­pios Fundamentais (FlexÃ­veis)

Estes princÃ­pios devem ser considerados, mas podem ser adaptados conforme o contexto:

1. **Single Responsibility**: Cada controller/service tem uma responsabilidade Ãºnica
2. **SeparaÃ§Ã£o de camadas**: Controllers orquestram, Services executam lÃ³gica, Models gerenciam dados
3. **Manutenibilidade**: Priorizar cÃ³digo limpo e testÃ¡vel sobre seguir padrÃµes cegamente
4. **Contexto primeiro**: Cada mÃ³dulo tem necessidades especÃ­ficas - adapte os padrÃµes

## ğŸ® PadrÃµes de Controllers

### Single-Action Controllers

**PadrÃ£o atual**: Um controller = uma aÃ§Ã£o (invocÃ¡vel via `__invoke()`)

**âœ… Vantagens:**
- Responsabilidade Ãºnica e clara
- FÃ¡cil de encontrar e entender
- OrganizaÃ§Ã£o por aÃ§Ã£o, nÃ£o por classe

**Estrutura bÃ¡sica:**

```php
<?php

declare(strict_types = 1);

namespace App\Http\Controllers\User;

use App\Http\Controllers\Controller;
use App\Models\User;
use Illuminate\Http\Request;
use Inertia\Inertia;
use Inertia\Response;

final class IndexController extends Controller
{
    public function __construct(
        private readonly RoleFilterService $roleFilterService
    ) {
    }

    public function __invoke(Request $request): Response
    {
        // 1. AutorizaÃ§Ã£o sempre primeiro
        $this->authorize('viewAny', User::class);

        // 2. Construir query
        $query = User::query()->with(['role', 'permissions']);

        // 3. Aplicar filtros
        // ...

        // 4. Retornar resposta
        return Inertia::render('users/index', [
            'users' => $users,
        ]);
    }
}
```

### Quando Adaptar os PadrÃµes

**âœ… Considere uma abordagem diferente quando:**

- A aÃ§Ã£o Ã© muito simples (pode manter lÃ³gica inline)
- NÃ£o hÃ¡ necessidade de Services (lÃ³gica simples)
- O mÃ³dulo tem requisitos especÃ­ficos que nÃ£o se encaixam no padrÃ£o
- HÃ¡ uma soluÃ§Ã£o mais simples e eficiente para o contexto

**Exemplos de adaptaÃ§Ãµes vÃ¡lidas:**

```php
// Controller simples - pode nÃ£o precisar de Service
final class ToggleActiveController extends Controller
{
    public function __invoke(Request $request, User $user): RedirectResponse
    {
        $this->authorize('toggleActive', $user);
        
        // LÃ³gica simples inline - nÃ£o precisa de Service
        $user->update(['is_active' => !$user->is_active]);
        
        return redirect()->back()->with('success', 'Status alterado');
    }
}

// Controller com lÃ³gica complexa - extrair para Service
final class StoreController extends Controller
{
    public function __construct(
        private readonly UserCreationService $userCreationService
    ) {
    }

    public function __invoke(StoreUserRequest $request): RedirectResponse
    {
        $this->authorize('create', User::class);
        
        // LÃ³gica complexa delegada para Service
        $user = $this->userCreationService->create($request->validated(), $request->user());
        
        return redirect()->route('users.show', $user);
    }
}
```

### Estrutura de Controller (Ordem Recomendada)

1. **AutorizaÃ§Ã£o** (`$this->authorize()`) - sempre primeiro
2. **ValidaÃ§Ã£o** (via Form Request ou `$request->validate()`)
3. **ConstruÃ§Ã£o de query/lÃ³gica** (ou chamada a Service)
4. **Processamento** (criaÃ§Ã£o, atualizaÃ§Ã£o, etc.)
5. **Cache invalidation** (se necessÃ¡rio)
6. **Logging** (para aÃ§Ãµes importantes)
7. **Resposta** (redirect, JSON, Inertia render)

### Dependency Injection

**âœ… Usar DI via constructor:**

```php
final class IndexController extends Controller
{
    public function __construct(
        private readonly RoleFilterService $roleFilterService,
        private readonly SomeOtherService $otherService
    ) {
    }
}
```

**âŒ Evitar:**

```php
// NÃ£o usar resolve() ou app() dentro dos mÃ©todos
$service = app(RoleFilterService::class); // âŒ
```

## ğŸ”§ Services

### Quando Criar Services

**âœ… Criar Service quando:**
- LÃ³gica complexa que pode ser reutilizada
- MÃºltiplos controllers precisam da mesma lÃ³gica
- LÃ³gica de negÃ³cio que nÃ£o pertence ao controller
- LÃ³gica que precisa ser testada isoladamente

**âŒ NÃ£o criar Service quando:**
- LÃ³gica muito simples (manter inline)
- Apenas para seguir padrÃ£o (sem benefÃ­cio real)
- Adiciona complexidade desnecessÃ¡ria

### PadrÃ£o de Service

```php
<?php

declare(strict_types = 1);

namespace App\Services;

use App\Models\User;
use Illuminate\Support\Collection;

final class RoleFilterService
{
    public function __construct(
        private readonly ImpersonationService $impersonationService
    ) {
    }

    public function getAssignableRoles(User $user): Collection
    {
        // LÃ³gica complexa aqui
        // ...
    }
}
```

**CaracterÃ­sticas:**
- `final class` quando nÃ£o precisa ser estendida
- `private readonly` para dependÃªncias
- MÃ©todos pÃºblicos focados e bem nomeados
- Type hints explÃ­citos

### Services para LÃ³gica Complexa

**Exemplo: RoleFilterService**

```php
final class RoleFilterService
{
    // LÃ³gica complexa de filtragem de roles
    // Cache de permissÃµes
    // ValidaÃ§Ãµes de hierarquia
    // ReutilizÃ¡vel em mÃºltiplos controllers
}
```

## ğŸ“ Form Requests

### ValidaÃ§Ã£o e AutorizaÃ§Ã£o

**Sempre usar Form Requests para validaÃ§Ã£o:**

```php
<?php

namespace App\Http\Requests\User;

use App\Models\Role;
use App\Models\User;
use Illuminate\Foundation\Http\FormRequest;

class StoreUserRequest extends FormRequest
{
    // AutorizaÃ§Ã£o no Form Request
    public function authorize(): bool
    {
        return $this->user()->can('create', User::class);
    }

    // Regras de validaÃ§Ã£o
    public function rules(): array
    {
        return [
            'name'  => ['required', 'string', 'max:255'],
            'email' => [
                'required',
                'string',
                'lowercase',
                'email',
                'max:255',
                'unique:' . User::class,
            ],
            'password' => ['required', 'confirmed', Password::defaults()],
            'role_id' => [
                'nullable',
                'exists:' . Role::class . ',id',
            ],
        ];
    }

    // Mensagens customizadas
    public function messages(): array
    {
        return [
            'name.required' => 'O nome Ã© obrigatÃ³rio.',
            'email.unique'  => 'Este email jÃ¡ estÃ¡ em uso.',
        ];
    }
}
```

**âœ… Vantagens:**
- SeparaÃ§Ã£o de responsabilidades
- ReutilizaÃ§Ã£o de validaÃ§Ã£o
- Mensagens customizadas
- AutorizaÃ§Ã£o no Form Request

## ğŸ›¡ï¸ Policies

### Quando Usar Policies

**âœ… Criar Policy quando:**
- LÃ³gica de autorizaÃ§Ã£o Ã© complexa
- HÃ¡ regras especÃ­ficas por papel/role
- Precisa de autorizaÃ§Ã£o baseada em relacionamentos
- LÃ³gica de autorizaÃ§Ã£o precisa ser reutilizada

**âŒ NÃ£o criar Policy quando:**
- AutorizaÃ§Ã£o Ã© simples (apenas verificar permissÃ£o)
- Pode usar `$this->authorize('permission_name')` diretamente

### PadrÃ£o de Policy

```php
<?php

namespace App\Policies;

use App\Models\User;

class UserPolicy
{
    public function viewAny(User $user): bool
    {
        return $user->hasPermissionTo('manage_users');
    }

    public function view(User $user, User $model): bool
    {
        return $user->hasPermissionTo('manage_users');
    }

    public function create(User $user): bool
    {
        return $user->hasPermissionTo('manage_users');
    }

    public function update(User $user, User $model): bool
    {
        if (!$user->hasPermissionTo('manage_users')) {
            return false;
        }

        // LÃ³gica especÃ­fica
        if ($user->id === $model->id && request()->has('is_active')) {
            return false;
        }

        return true;
    }

    public function delete(User $user, User $model): bool
    {
        // LÃ³gica complexa de autorizaÃ§Ã£o
        // ...
    }

    // MÃ©todos customizados
    public function toggleActive(User $user, User $model): bool
    {
        // LÃ³gica especÃ­fica
    }
}
```

## âš¡ Performance e OtimizaÃ§Ã£o

### Eager Loading

**âœ… Sempre usar eager loading explÃ­cito:**

```php
// âœ… CORRETO: Eager loading explÃ­cito
$users = User::query()
    ->with(['role', 'permissions'])
    ->paginate(15);

// âŒ EVITAR: Eager loading automÃ¡tico no Model
// protected $with = ['role']; // NÃ£o usar isso
```

**RazÃ£o**: Evitar N+1 queries e controlar exatamente o que Ã© carregado.

### Query Optimization

**âœ… Whitelist de campos permitidos:**

```php
// âœ… CORRETO: Validar campos de ordenaÃ§Ã£o
$allowedSortFields = ['name', 'email', 'created_at', 'updated_at'];

if (in_array($sortBy, $allowedSortFields)) {
    $query->orderBy($sortBy, $sortOrder);
} else {
    $query->orderBy('created_at', 'desc'); // Fallback seguro
}
```

**âœ… Filtrar antes de buscar:**

```php
// âœ… CORRETO: Filtrar antes de paginar
$query = User::query()
    ->where('is_active', true)
    ->whereHas('role', fn($q) => $q->where('name', '!=', 'visitor'))
    ->with(['role'])
    ->paginate(15);
```

### Cache Strategies

**âœ… Usar cache para dados frequentes:**

```php
// Cache de permissÃµes (dados que mudam raramente)
$permissions = Cache::rememberForever(
    "user:$userId:permissions",
    fn() => $user->getAllPermissions()->pluck('name')->toArray()
);

// Invalidar cache quando necessÃ¡rio
Cache::forget("user:$userId:permissions");
```

**âœ… Quando usar cache:**
- Dados que mudam raramente
- CÃ¡lculos pesados
- Consultas frequentes

**âŒ NÃ£o usar cache para:**
- Dados que mudam frequentemente
- Dados sensÃ­veis que precisam estar sempre atualizados
- Dados simples que nÃ£o tÃªm impacto na performance

### PaginaÃ§Ã£o

**âœ… Sempre usar paginaÃ§Ã£o para listagens:**

```php
// âœ… CORRETO: PaginaÃ§Ã£o com query string
$users = $query->paginate($perPage)->withQueryString();

// Retornar dados paginados
return Inertia::render('users/index', [
    'users' => $users->items(),
    'pagination' => [
        'current_page' => $users->currentPage(),
        'last_page'    => $users->lastPage(),
        'per_page'     => $users->perPage(),
        'total'        => $users->total(),
    ],
]);
```

### Database Indexes

**âœ… Adicionar Ã­ndices em colunas frequentemente consultadas:**

```php
// Migration
Schema::table('users', function (Blueprint $table) {
    $table->index('email');
    $table->index('role_id');
    $table->index(['is_active', 'created_at']);
});
```

## ğŸ”’ SeguranÃ§a

### AutorizaÃ§Ã£o

**âœ… Sempre verificar permissÃ£o primeiro:**

```php
public function __invoke(Request $request): Response
{
    // âœ… SEMPRE PRIMEIRO
    $this->authorize('viewAny', User::class);
    
    // Resto da lÃ³gica...
}
```

**âœ… Duas camadas de seguranÃ§a:**
1. **Frontend**: Ocultar botÃµes/aÃ§Ãµes (UX)
2. **Backend**: Verificar permissÃ£o (seguranÃ§a real)

### ValidaÃ§Ã£o

**âœ… Sempre validar dados:**

```php
// âœ… CORRETO: Form Request
public function __invoke(StoreUserRequest $request): RedirectResponse
{
    $data = $request->validated(); // JÃ¡ validado
}

// âœ… CORRETO: ValidaÃ§Ã£o inline (se simples)
$validated = $request->validate([
    'name' => 'required|string|max:255',
]);
```

### SanitizaÃ§Ã£o

**âœ… Laravel sanitiza automaticamente, mas seja explÃ­cito:**

```php
// âœ… CORRETO: ValidaÃ§Ã£o com sanitizaÃ§Ã£o
'email' => ['required', 'string', 'lowercase', 'email'],

// âœ… CORRETO: Escape automÃ¡tico em views
{{ $user->name }} // Automaticamente escapado

// âŒ EVITAR: Output nÃ£o escapado
{!! $user->name !!} // Apenas se confiar 100% no conteÃºdo
```

### SQL Injection Prevention

**âœ… Eloquent previne SQL injection automaticamente:**

```php
// âœ… SEGURO: Eloquent
User::where('email', $email)->first();

// âœ… SEGURO: Query Builder
DB::table('users')->where('email', $email)->first();

// âŒ PERIGOSO: Raw queries (evitar quando possÃ­vel)
DB::select("SELECT * FROM users WHERE email = '$email'");
```

### Type Safety

**âœ… Sempre usar strict types:**

```php
<?php

declare(strict_types = 1); // âœ… SEMPRE

namespace App\Http\Controllers\User;
```

**BenefÃ­cios:**
- DetecÃ§Ã£o de erros em tempo de desenvolvimento
- Melhor IDE support
- CÃ³digo mais robusto

## ğŸ§¹ OrganizaÃ§Ã£o e Manutenibilidade

### PrincÃ­pios SOLID

**Single Responsibility Principle:**
- Cada controller tem uma Ãºnica aÃ§Ã£o
- Cada service tem uma responsabilidade clara
- Cada policy gerencia autorizaÃ§Ã£o de um modelo

**Open/Closed Principle:**
- Services extensÃ­veis via DI
- Policies podem ser estendidas

**Dependency Inversion:**
- Depender de abstraÃ§Ãµes (interfaces) quando necessÃ¡rio
- DI via constructor

### Clean Code

**âœ… Boas prÃ¡ticas:**

```php
// âœ… Nomes descritivos
public function getAssignableRolesForCurrentSession(User $user): Collection

// âœ… FunÃ§Ãµes pequenas e focadas
public function __invoke(Request $request): Response
{
    // MÃ¡ximo ~50-100 linhas
    // Se maior, extrair para Service
}

// âœ… ComentÃ¡rios quando necessÃ¡rio (explicar "por quÃª")
// Se estiver impersonando, usa o usuÃ¡rio original para validaÃ§Ãµes
$effectiveUser = $this->impersonationService->getOriginalUser() ?? $request->user();

// âœ… Sem cÃ³digo duplicado
// Extrair lÃ³gica comum para Services ou Traits
```

### Type Safety

**âœ… Sempre usar type hints:**

```php
// âœ… CORRETO: Type hints explÃ­citos
public function __invoke(StoreUserRequest $request): RedirectResponse
{
    // ...
}

// âœ… CORRETO: Return types
public function getAssignableRoles(User $user): Collection
{
    // ...
}
```

### Final Classes

**âœ… Usar `final` quando nÃ£o precisa ser estendida:**

```php
// âœ… CORRETO: Final class para controllers/services
final class IndexController extends Controller
{
    // ...
}

// âœ… CORRETO: Final class para Services
final class RoleFilterService
{
    // ...
}
```

**BenefÃ­cios:**
- Previne extensÃ£o nÃ£o intencional
- Melhor performance
- CÃ³digo mais claro

## ğŸ“¦ Resources (API Resources)

### Quando Usar Resources

**âœ… Usar Resources quando:**
- Transformar dados para API/Inertia
- FormataÃ§Ã£o consistente de dados
- Ocultar campos sensÃ­veis
- Adicionar campos calculados

**Exemplo:**

```php
<?php

namespace App\Http\Resources;

use Illuminate\Http\Request;
use Illuminate\Http\Resources\Json\JsonResource;

class UserResource extends JsonResource
{
    public function toArray(Request $request): array
    {
        return [
            'id'        => $this->id,
            'name'      => $this->name,
            'email'     => $this->email,
            'role'      => $this->whenLoaded('role', fn() => [
                'id'    => $this->role->id,
                'name'  => $this->role->name,
                'label' => $this->role->label,
            ]),
            'is_active' => $this->is_active,
        ];
    }

    // MÃ©todo helper para collections
    public static function toArrayCollection($collection, Request $request): array
    {
        return static::collection($collection)->toArray($request);
    }
}
```

## ğŸ§ª Testabilidade

### Estrutura de Testes

**âœ… Organizar testes por funcionalidade:**

```
tests/
â”œâ”€â”€ Feature/
â”‚   â””â”€â”€ User/
â”‚       â”œâ”€â”€ IndexTest.php
â”‚       â”œâ”€â”€ StoreTest.php
â”‚       â””â”€â”€ UpdateTest.php
â””â”€â”€ Unit/
    â””â”€â”€ Services/
        â””â”€â”€ RoleFilterServiceTest.php
```

### Testes de Controllers

**âœ… Testar autorizaÃ§Ã£o, validaÃ§Ã£o e lÃ³gica:**

```php
public function test_user_cannot_view_users_without_permission(): void
{
    $user = User::factory()->create();
    
    $response = $this->actingAs($user)
        ->get(route('users.index'));
    
    $response->assertForbidden();
}

public function test_user_can_view_users_with_permission(): void
{
    $user = User::factory()->create();
    $user->givePermissionTo('manage_users');
    
    $response = $this->actingAs($user)
        ->get(route('users.index'));
    
    $response->assertOk();
}
```

### Testes de Services

**âœ… Testar lÃ³gica isolada:**

```php
public function test_get_assignable_roles_filters_by_priority(): void
{
    $user = User::factory()->create();
    $user->assignRole(Roles::MANAGER);
    
    $service = new RoleFilterService($this->mockImpersonationService());
    $roles = $service->getAssignableRoles($user);
    
    $this->assertTrue($roles->every(fn($role) => $role->priority < $user->role->priority));
}
```

## ğŸ“‹ Checklist de ImplementaÃ§Ã£o

> **Lembre-se**: Este checklist Ã© um **guia**, nÃ£o uma lista obrigatÃ³ria. Marque apenas o que for relevante para seu mÃ³dulo.

### Novo Controller

- [ ] Controller Ã© single-action (`__invoke()`)
- [ ] `declare(strict_types = 1)` no inÃ­cio
- [ ] `final class` quando nÃ£o precisa ser estendida
- [ ] AutorizaÃ§Ã£o sempre primeiro (`$this->authorize()`)
- [ ] Dependency Injection via constructor
- [ ] Type hints explÃ­citos em parÃ¢metros e retorno
- [ ] Eager loading explÃ­cito quando necessÃ¡rio
- [ ] PaginaÃ§Ã£o para listagens
- [ ] Logging para aÃ§Ãµes importantes
- [ ] Cache invalidation quando necessÃ¡rio

### Novo Service

- [ ] Service criado apenas se lÃ³gica Ã© complexa/reutilizÃ¡vel
- [ ] `final class` quando nÃ£o precisa ser estendida
- [ ] `private readonly` para dependÃªncias
- [ ] MÃ©todos pÃºblicos bem nomeados
- [ ] Type hints explÃ­citos
- [ ] LÃ³gica testÃ¡vel isoladamente

### Novo Form Request

- [ ] ValidaÃ§Ã£o completa de dados
- [ ] AutorizaÃ§Ã£o no Form Request
- [ ] Mensagens customizadas
- [ ] Regras customizadas quando necessÃ¡rio

### Nova Policy

- [ ] Policy criada apenas se lÃ³gica de autorizaÃ§Ã£o Ã© complexa
- [ ] MÃ©todos padrÃ£o (viewAny, view, create, update, delete)
- [ ] MÃ©todos customizados quando necessÃ¡rio
- [ ] LÃ³gica clara e testÃ¡vel

### Performance

- [ ] Eager loading explÃ­cito (evitar N+1)
- [ ] Whitelist de campos permitidos para ordenaÃ§Ã£o/filtro
- [ ] Cache para dados frequentes
- [ ] Ãndices em colunas frequentemente consultadas
- [ ] PaginaÃ§Ã£o adequada

### SeguranÃ§a

- [ ] AutorizaÃ§Ã£o verificada no controller
- [ ] ValidaÃ§Ã£o de dados (Form Request)
- [ ] SanitizaÃ§Ã£o de inputs
- [ ] Type safety (strict_types)
- [ ] ProteÃ§Ã£o contra SQL injection (Eloquent)
- [ ] ProteÃ§Ã£o XSS (escape automÃ¡tico)

### Qualidade

- [ ] Sem erros de lint
- [ ] CÃ³digo limpo e legÃ­vel
- [ ] ComentÃ¡rios quando necessÃ¡rio
- [ ] Sem cÃ³digo duplicado
- [ ] Testes quando apropriado

## ğŸ” Exemplo Completo: MÃ³dulo de UsuÃ¡rios

### Estrutura

```
app/
â”œâ”€â”€ Http/
â”‚   â”œâ”€â”€ Controllers/User/
â”‚   â”‚   â”œâ”€â”€ IndexController.php
â”‚   â”‚   â”œâ”€â”€ StoreController.php
â”‚   â”‚   â””â”€â”€ UpdateController.php
â”‚   â”œâ”€â”€ Requests/User/
â”‚   â”‚   â”œâ”€â”€ StoreUserRequest.php
â”‚   â”‚   â””â”€â”€ UpdateUserRequest.php
â”‚   â””â”€â”€ Resources/
â”‚       â””â”€â”€ UserResource.php
â”œâ”€â”€ Services/
â”‚   â”œâ”€â”€ RoleFilterService.php
â”‚   â””â”€â”€ ImpersonationService.php
â””â”€â”€ Policies/
    â””â”€â”€ UserPolicy.php
```

### IndexController (Listagem)

```php
final class IndexController extends Controller
{
    public function __construct(
        private readonly RoleFilterService $roleFilterService
    ) {
    }

    public function __invoke(Request $request): Response
    {
        $this->authorize('viewAny', User::class);

        $query = User::query()->with(['role', 'permissions']);

        // Filtros
        if ($request->filled('search')) {
            $query->where(function($q) use ($request) {
                $q->where('name', 'like', "%{$request->search}%")
                  ->orWhere('email', 'like', "%{$request->search}%");
            });
        }

        // OrdenaÃ§Ã£o com whitelist
        $allowedSortFields = ['name', 'email', 'created_at'];
        $sortBy = in_array($request->get('sort_by'), $allowedSortFields)
            ? $request->get('sort_by')
            : 'created_at';

        $query->orderBy($sortBy, $request->get('sort_order', 'desc'));

        // PaginaÃ§Ã£o
        $users = $query->paginate($request->get('per_page', 15))->withQueryString();

        return Inertia::render('users/index', [
            'users' => UserResource::collection($users->items())->toArray($request),
            'pagination' => [
                'current_page' => $users->currentPage(),
                'last_page'    => $users->lastPage(),
                'per_page'     => $users->perPage(),
                'total'        => $users->total(),
            ],
        ]);
    }
}
```

## ğŸ“š ReferÃªncias

- **PadrÃ£o**: Single-Action Controllers (nÃ£o Actions Pattern)
- **Sem Repositories**: Usar Eloquent diretamente
- **Services**: Para lÃ³gica complexa e reutilizÃ¡vel
- **Form Requests**: Para validaÃ§Ã£o
- **Policies**: Para autorizaÃ§Ã£o complexa
- **Performance**: Eager loading, cache, Ã­ndices
- **SeguranÃ§a**: AutorizaÃ§Ã£o, validaÃ§Ã£o, sanitizaÃ§Ã£o
- **Manutenibilidade**: SOLID, clean code, type safety

## ğŸ’¡ Dicas Importantes

### Backend (Laravel)

1. **Use este guia como referÃªncia, nÃ£o como regra**: Adapte conforme necessÃ¡rio
2. **Contexto primeiro**: Cada mÃ³dulo tem necessidades especÃ­ficas - adapte os padrÃµes
3. **Simplicidade sobre padrÃ£o**: Se uma soluÃ§Ã£o simples funciona melhor, use-a
4. **Priorize manutenibilidade**: CÃ³digo limpo e testÃ¡vel Ã© mais importante que seguir padrÃµes
5. **Sempre verifique permissÃ£o primeiro**: `$this->authorize()` deve ser a primeira linha do mÃ©todo
6. **Use Services quando necessÃ¡rio**: Apenas para lÃ³gica complexa/reutilizÃ¡vel
7. **Use Policies para autorizaÃ§Ã£o complexa**: LÃ³gica simples pode usar `can()` diretamente
8. **Eager loading sempre explÃ­cito**: Evite `$with` no Model
9. **Type safety sempre**: `declare(strict_types = 1)` em todos arquivos
10. **Cache quando apropriado**: Dados frequentes que mudam raramente
11. **Teste autorizaÃ§Ã£o**: Sempre testar que usuÃ¡rios nÃ£o autorizados sÃ£o bloqueados
12. **Valide no backend**: Nunca confie apenas em validaÃ§Ãµes do frontend
13. **Logging para aÃ§Ãµes importantes**: Criar, atualizar, deletar registros importantes
14. **Whitelist de campos**: Sempre validar campos de ordenaÃ§Ã£o/filtro
15. **PaginaÃ§Ã£o para listagens**: Nunca retornar todos os registros sem paginaÃ§Ã£o
